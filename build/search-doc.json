[{"title":"Sorbet","type":0,"sectionRef":"#","url":"/Status/api/Sorbet","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Sorbet","url":"/Status/api/Sorbet#types","content":" "},{"title":"FSM​","type":1,"pageTitle":"Sorbet","url":"/Status/api/Sorbet#FSM","content":"&lt;/&gt; type FSM = {} IsRUnning boolean InitialState State ActiveEntities {[Entity]: true} } A state machine class that allows a collection of entities change their states based on certain conditions &amp; events.  "},{"title":"State​","type":1,"pageTitle":"Sorbet","url":"/Status/api/Sorbet#State","content":"&lt;/&gt; type State = {} Name: string, OnUpdate : (entity: Entity, fsm: FSM, dt: number) -&gt; nil, OnExit : (entity: Entity, fsm: FSM) -&gt; nil, Entities : { [Entity]: true }, } represents a specific mode of an entity within the state machine.  "},{"title":"Entity​","type":1,"pageTitle":"Sorbet","url":"/Status/api/Sorbet#Entity","content":"&lt;/&gt; type Entity = any Literally anything. "},{"title":"Functions​","type":1,"pageTitle":"Sorbet","url":"/Status/api/Sorbet#functions","content":" "},{"title":"RegisterEntity​","type":1,"pageTitle":"Sorbet","url":"/Status/api/Sorbet#RegisterEntity","content":"&lt;/&gt; Sorbet:RegisterEntity( fsm: FSM,-- The FSM object. entity: Entity,-- The entity to register in the state machine. initialState: State-- Optional. The initial state for the entity. If not provided, the FSM's initial state is used. ) → () Registers an entity in the state machine with an optional initial state. If the entity is already registered, a warning is displayed. If no initial state is provided, the state machine's initial state is used. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/Status/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/Status/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "}]